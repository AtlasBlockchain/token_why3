(* A handwritten Why3 input for a token contract. *)

module UInt256
	use import mach.int.Unsigned
	type uint256
	constant max_uint256: int = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
	clone export mach.int.Unsigned with
		type t = uint256,
		constant max = max_uint256
end

module Address
	use import mach.int.Unsigned
	type address
	constant max_address: int = 0xffffffffffffffffffffffffffffffffffffffff (* 160 bit = 40 f's *)
	clone export mach.int.Unsigned with
		type t = address,
		constant max = max_address
end

module TokenContract (* or a theory? *)

  use Address
  use import UInt256

  (* TODO: avoid using generic array but use a constant-length one *)
  use import array.Array

  let transfer (_from : Address.address) (_to : Address.address) (_val : uint256) (_orig : array uint256) : array uint256

  (* when the constant length array comes, this condition can go away. *)
  requires { Address.to_int _to < _orig.length }

  (* This condition should also go away when the array is of
   * the constant length *)
  requires { Address.to_int _from < _orig.length }

  (* This condition should go away with a guard in the program. *)
  requires { to_int _orig[Address.to_int _from] >= to_int _val }

  (* This condition should be replaced with a more general condition *)
  requires { to_int _orig[Address.to_int _from] <= to_int _val + max_uint256 }

  (* This condition should be replaced with a more general condition *)
  requires { to_int _orig[Address.to_int _to] + to_int _val <= max_uint256 }

  = _orig[Address.to_int _from] <- _orig[Address.to_int _from] - _val;
	_orig[Address.to_int _to] <- _orig[Address.to_int _to] + _val;
    _orig

end


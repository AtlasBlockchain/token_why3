(* A handwritten Why3 input for a token contract. *)

module UInt256
	use import mach.int.Unsigned
	type uint256
	constant max_uint256: int = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff
	clone export mach.int.Unsigned with
		type t = uint256,
		constant max = max_uint256
end

module Address
	use import mach.int.Unsigned
	type address
	constant max_address: int = 0xffffffffffffffffffffffffffffffffffffffff (* 160 bit = 40 f's *)
	clone export mach.int.Unsigned with
		type t = address,
		constant max = max_address
end

module TokenContract (* or a theory? *)

  use import UInt256
  use import Address

  (* TODO: avoid using generic array but use a constant-length one *)
  use import array.Array

  let transfer (_from : address) (_to : address) (_orig : array uint256) : array uint256

  (* when the constant length array comes, this condition can go away. *)
  requires { to_int _to < _orig.length }

  (* This conditions should also go away when the array is of
   * the constant length *)
  requires { to_int _from < _orig.length }
  =
    _orig[to_int _to] <- _orig[to_int _to];
    _orig[to_int _from] <- _orig[to_int _from];
    _orig

end

